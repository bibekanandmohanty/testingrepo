{"version":3,"file":"magic-wand.js","sources":["../src/MagicWand.js"],"sourcesContent":["ï»¿    \r\nMagicWand = (function () {\r\n    var lib = {};\r\n\r\n    /** Create a binary mask on the image by color threshold\r\n      * Algorithm: Scanline flood fill (http://en.wikipedia.org/wiki/Flood_fill)\r\n      * @param {Object} image: {Uint8Array} data, {int} width, {int} height, {int} bytes\r\n      * @param {int} x of start pixel\r\n      * @param {int} y of start pixel\r\n      * @param {int} color threshold\r\n      * @param {Uint8Array} mask of visited points (optional) \r\n      * @param {boolean} [includeBorders=false] indicate whether to include borders pixels\r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.floodFill = function(image, px, py, colorThreshold, mask, includeBorders) {\r\n        return includeBorders\r\n            ? floodFillWithBorders(image, px, py, colorThreshold, mask)\r\n            : floodFillWithoutBorders(image, px, py, colorThreshold, mask);\r\n    };\r\n\r\n    function floodFillWithoutBorders(image, px, py, colorThreshold, mask) {\r\n\r\n        var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n            data = image.data,\r\n            w = image.width,\r\n            h = image.height,\r\n            bytes = image.bytes, // number of bytes in the color\r\n            maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n            i = py * w + px, // start point index in the mask data\r\n            result = new Uint8Array(w * h), // result mask\r\n            visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n\r\n        if (visited[i] === 1) return null;\r\n\r\n        i = i * bytes; // start point index in the image data\r\n        var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n\r\n        var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n        do {\r\n            el = stack.shift(); // get line for scanning\r\n\r\n            checkY = false;\r\n            for (x = el.left + 1; x < el.right; x++) {\r\n                dy = el.y * w;\r\n                i = (dy + x) * bytes; // point index in the image data\r\n\r\n                if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n                // compare the color of the sample\r\n                c = data[i] - sampleColor[0]; // check by red\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 1] - sampleColor[1]; // check by green\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 2] - sampleColor[2]; // check by blue\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n\r\n                checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n\r\n                result[dy + x] = 1; // mark a new point in mask\r\n                visited[dy + x] = 1; // mark a new point as visited\r\n\r\n                xl = x - 1;\r\n                // walk to left side starting with the left neighbor\r\n                while (xl > -1) {\r\n                    dyl = dy + xl;\r\n                    i = dyl * bytes; // point index in the image data\r\n                    if (visited[dyl] === 1) break; // check whether the point has been visited\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                    result[dyl] = 1;\r\n                    visited[dyl] = 1;\r\n\r\n                    xl--;\r\n                }\r\n                xr = x + 1;\r\n                // walk to right side starting with the right neighbor\r\n                while (xr < w) {\r\n                    dyr = dy + xr;\r\n                    i = dyr * bytes; // index point in the image data\r\n                    if (visited[dyr] === 1) break; // check whether the point has been visited\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n\r\n                    result[dyr] = 1;\r\n                    visited[dyr] = 1;\r\n\r\n                    xr++;\r\n                }\r\n\r\n                // check minmax for X\r\n                if (xl < minX) minX = xl + 1;\r\n                if (xr > maxX) maxX = xr - 1;\r\n\r\n                newY = el.y - el.dir;\r\n                if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                    if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\r\n                    if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\r\n                }\r\n                newY = el.y + el.dir;\r\n                if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                    if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\r\n                }\r\n            }\r\n            // check minmax for Y if necessary\r\n            if (checkY) {\r\n                if (el.y < minY) minY = el.y;\r\n                if (el.y > maxY) maxY = el.y;\r\n            }\r\n        } while (stack.length > 0);\r\n\r\n        return {\r\n            data: result,\r\n            width: image.width,\r\n            height: image.height,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    function floodFillWithBorders(image, px, py, colorThreshold, mask) {\r\n\r\n        var c, x, newY, el, xr, xl, dy, dyl, dyr, checkY,\r\n            data = image.data,\r\n            w = image.width,\r\n            h = image.height,\r\n            bytes = image.bytes, // number of bytes in the color\r\n            maxX = -1, minX = w + 1, maxY = -1, minY = h + 1,\r\n            i = py * w + px, // start point index in the mask data\r\n            result = new Uint8Array(w * h), // result mask\r\n            visited = new Uint8Array(mask ? mask : w * h); // mask of visited points\r\n\r\n        if (visited[i] === 1) return null;\r\n\r\n        i = i * bytes; // start point index in the image data\r\n        var sampleColor = [data[i], data[i + 1], data[i + 2], data[i + 3]]; // start point color (sample)\r\n\r\n        var stack = [{ y: py, left: px - 1, right: px + 1, dir: 1 }]; // first scanning line\r\n        do {\r\n            el = stack.shift(); // get line for scanning\r\n\r\n            checkY = false;\r\n            for (x = el.left + 1; x < el.right; x++) {\r\n                dy = el.y * w;\r\n                i = (dy + x) * bytes; // point index in the image data\r\n\r\n                if (visited[dy + x] === 1) continue; // check whether the point has been visited\r\n\r\n                checkY = true; // if the color of the new point(x,y) is similar to the sample color need to check minmax for Y \r\n\r\n                result[dy + x] = 1; // mark a new point in mask\r\n                visited[dy + x] = 1; // mark a new point as visited\r\n\r\n                // compare the color of the sample\r\n                c = data[i] - sampleColor[0]; // check by red\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 1] - sampleColor[1]; // check by green\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n                c = data[i + 2] - sampleColor[2]; // check by blue\r\n                if (c > colorThreshold || c < -colorThreshold) continue;\r\n\r\n                xl = x - 1;\r\n                // walk to left side starting with the left neighbor\r\n                while (xl > -1) {\r\n                    dyl = dy + xl;\r\n                    i = dyl * bytes; // point index in the image data\r\n                    if (visited[dyl] === 1) break; // check whether the point has been visited\r\n\r\n                    result[dyl] = 1;\r\n                    visited[dyl] = 1;\r\n                    xl--;\r\n\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                }\r\n                xr = x + 1;\r\n                // walk to right side starting with the right neighbor\r\n                while (xr < w) {\r\n                    dyr = dy + xr;\r\n                    i = dyr * bytes; // index point in the image data\r\n                    if (visited[dyr] === 1) break; // check whether the point has been visited\r\n\r\n                    result[dyr] = 1;\r\n                    visited[dyr] = 1;\r\n                    xr++;\r\n\r\n                    // compare the color of the sample\r\n                    c = data[i] - sampleColor[0]; // check by red\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 1] - sampleColor[1]; // check by green\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                    c = data[i + 2] - sampleColor[2]; // check by blue\r\n                    if (c > colorThreshold || c < -colorThreshold) break;\r\n                }\r\n\r\n                // check minmax for X\r\n                if (xl < minX) minX = xl + 1;\r\n                if (xr > maxX) maxX = xr - 1;\r\n\r\n                newY = el.y - el.dir;\r\n                if (newY >= 0 && newY < h) { // add two scanning lines in the opposite direction (y - dir) if necessary\r\n                    if (xl < el.left) stack.push({ y: newY, left: xl, right: el.left, dir: -el.dir }); // from \"new left\" to \"current left\"\r\n                    if (el.right < xr) stack.push({ y: newY, left: el.right, right: xr, dir: -el.dir }); // from \"current right\" to \"new right\"\r\n                }\r\n                newY = el.y + el.dir;\r\n                if (newY >= 0 && newY < h) { // add the scanning line in the direction (y + dir) if necessary\r\n                    if (xl < xr) stack.push({ y: newY, left: xl, right: xr, dir: el.dir }); // from \"new left\" to \"new right\"\r\n                }\r\n            }\r\n            // check minmax for Y if necessary\r\n            if (checkY) {\r\n                if (el.y < minY) minY = el.y;\r\n                if (el.y > maxY) maxY = el.y;\r\n            }\r\n        } while (stack.length > 0);\r\n\r\n        return {\r\n            data: result,\r\n            width: image.width,\r\n            height: image.height,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Apply the gauss-blur filter to binary mask\r\n      * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n      * http://www.librow.com/articles/article-9\r\n      * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.gaussBlur = function(mask, radius) {\r\n\r\n        var i, k, k1, x, y, val, start, end,\r\n            n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n            s2 = radius * radius,\r\n            wg = new Float32Array(n), // weights\r\n            total = 0, // sum of weights(used for normalization)\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY;\r\n\r\n        // calc gauss weights\r\n        for (i = 0; i < radius; i++) {\r\n            var dsq = (radius - i) * (radius - i);\r\n            var ww = Math.exp(-dsq / (2.0 * s2)) / (2 * Math.PI * s2);\r\n            wg[radius + i] = wg[radius - i] = ww;\r\n            total += 2 * ww;\r\n        }\r\n        // normalization weights\r\n        for (i = 0; i < n; i++) {\r\n            wg[i] /= total;\r\n        }\r\n\r\n        var result = new Uint8Array(w * h), // result mask\r\n            endX = radius + w,\r\n            endY = radius + h;\r\n\r\n        //walk through all source points for blur\r\n        for (y = minY; y < maxY + 1; y++)\r\n            for (x = minX; x < maxX + 1; x++) {\r\n                val = 0;\r\n                k = y * w + x; // index of the point\r\n                start = radius - x > 0 ? radius - x : 0;\r\n                end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n                k1 = k - radius;\r\n                // walk through x-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    val += data[k1 + i] * wg[i];\r\n                }\r\n                start = radius - y > 0 ? radius - y : 0;\r\n                end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n                k1 = k - radius * w;\r\n                // walk through y-neighbors\r\n                for (i = start; i < end; i++) {\r\n                    val += data[k1 + i * w] * wg[i];\r\n                }\r\n                result[k] = val > 0.5 ? 1 : 0;\r\n            }\r\n\r\n        return {\r\n            data: result,\r\n            width: w,\r\n            height: h,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Create a border index array of boundary points of the mask with radius-neighbors\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @param {Uint8Array} visited: mask of visited points (optional) \r\n      * @return {Array} border index array of boundary points with radius-neighbors (only points need for blur)\r\n      */\r\n    function createBorderForBlur(mask, radius, visited) {\r\n\r\n        var x, i, j, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            visitedData = new Uint8Array(data),\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            len = w * h,\r\n            temp = new Uint8Array(len), // auxiliary array to check uniqueness\r\n            border = [], // only border points\r\n            x0 = Math.max(minX, 1),\r\n            x1 = Math.min(maxX, w - 2),\r\n            y0 = Math.max(minY, 1),\r\n            y1 = Math.min(maxY, h - 2);\r\n\r\n        if (visited && visited.length > 0) {\r\n            // copy visited points (only \"black\")\r\n            for (k = 0; k < len; k++) {\r\n                if (visited[k] === 1) visitedData[k] = 1;\r\n            }\r\n        }\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = y0; y < y1 + 1; y++)\r\n            for (x = x0; x < x1 + 1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (visitedData[k + 1] === 0 || visitedData[k - 1] === 0 ||\r\n                    visitedData[k1] === 0 || visitedData[k1 + 1] === 0 || visitedData[k1 - 1] === 0 ||\r\n                    visitedData[k2] === 0 || visitedData[k2 + 1] === 0 || visitedData[k2 - 1] === 0) {\r\n                    //if (visitedData[k + 1] + visitedData[k - 1] + \r\n                    //    visitedData[k1] + visitedData[k1 + 1] + visitedData[k1 - 1] +\r\n                    //    visitedData[k2] + visitedData[k2 + 1] + visitedData[k2 - 1] == 8) continue;\r\n                    border.push(k);\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        if (minX == 0)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w] === 1)\r\n                    border.push(y * w);\r\n\r\n        if (maxX == w - 1)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w + maxX] === 1)\r\n                    border.push(y * w + maxX);\r\n\r\n        if (minY == 0)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[x] === 1)\r\n                    border.push(x);\r\n\r\n        if (maxY == h - 1)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[maxY * w + x] === 1)\r\n                    border.push(maxY * w + x);\r\n\r\n        var result = [], // border points with radius-neighbors\r\n            start, end,\r\n            endX = radius + w,\r\n            endY = radius + h,\r\n            n = radius * 2 + 1; // size of the pattern for radius-neighbors (from -r to +r with the center point)\r\n\r\n        len = border.length;\r\n        // walk through radius-neighbors of border points and add them to the result array\r\n        for (j = 0; j < len; j++) {\r\n            k = border[j]; // index of the border point\r\n            temp[k] = 1; // mark border point\r\n            result.push(k); // save the border point\r\n            x = k % w; // calc x by index\r\n            y = (k - x) / w; // calc y by index\r\n            start = radius - x > 0 ? radius - x : 0;\r\n            end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n            k1 = k - radius;\r\n            // walk through x-neighbors\r\n            for (i = start; i < end; i++) {\r\n                k2 = k1 + i;\r\n                if (temp[k2] === 0) { // check the uniqueness\r\n                    temp[k2] = 1;\r\n                    result.push(k2);\r\n                }\r\n            }\r\n            start = radius - y > 0 ? radius - y : 0;\r\n            end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n            k1 = k - radius * w;\r\n            // walk through y-neighbors\r\n            for (i = start; i < end; i++) {\r\n                k2 = k1 + i * w;\r\n                if (temp[k2] === 0) { // check the uniqueness\r\n                    temp[k2] = 1;\r\n                    result.push(k2);\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /** Apply the gauss-blur filter ONLY to border points with radius-neighbors\r\n      * Algorithms: http://blog.ivank.net/fastest-gaussian-blur.html\r\n      * http://www.librow.com/articles/article-9\r\n      * http://elynxsdk.free.fr/ext-docs/Blur/Fast_box_blur.pdf\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @param {int} blur radius\r\n      * @param {Uint8Array} visited: mask of visited points (optional) \r\n      * @return {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      */\r\n    lib.gaussBlurOnlyBorder = function(mask, radius, visited) {\r\n\r\n        var border = createBorderForBlur(mask, radius, visited), // get border points with radius-neighbors\r\n            ww, dsq, i, j, k, k1, x, y, val, start, end,\r\n            n = radius * 2 + 1, // size of the pattern for radius-neighbors (from -r to +r with center point)\r\n            s2 = 2 * radius * radius,\r\n            wg = new Float32Array(n), // weights\r\n            total = 0, // sum of weights(used for normalization)\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            len = border.length;\r\n\r\n        // calc gauss weights\r\n        for (i = 0; i < radius; i++) {\r\n            dsq = (radius - i) * (radius - i);\r\n            ww = Math.exp(-dsq / s2) / Math.PI;\r\n            wg[radius + i] = wg[radius - i] = ww;\r\n            total += 2 * ww;\r\n        }\r\n        // normalization weights\r\n        for (i = 0; i < n; i++) {\r\n            wg[i] /= total;\r\n        }\r\n\r\n        var result = new Uint8Array(data), // copy the source mask\r\n            endX = radius + w,\r\n            endY = radius + h;\r\n\r\n        //walk through all border points for blur\r\n        for (i = 0; i < len; i++) {\r\n            k = border[i]; // index of the border point\r\n            val = 0;\r\n            x = k % w; // calc x by index\r\n            y = (k - x) / w; // calc y by index\r\n            start = radius - x > 0 ? radius - x : 0;\r\n            end = endX - x < n ? endX - x : n; // Math.min((((w - 1) - x) + radius) + 1, n);\r\n            k1 = k - radius;\r\n            // walk through x-neighbors\r\n            for (j = start; j < end; j++) {\r\n                val += data[k1 + j] * wg[j];\r\n            }\r\n            if (val > 0.5) {\r\n                result[k] = 1;\r\n                // check minmax\r\n                if (x < minX) minX = x;\r\n                if (x > maxX) maxX = x;\r\n                if (y < minY) minY = y;\r\n                if (y > maxY) maxY = y;\r\n                continue;\r\n            }\r\n            start = radius - y > 0 ? radius - y : 0;\r\n            end = endY - y < n ? endY - y : n; // Math.min((((h - 1) - y) + radius) + 1, n);\r\n            k1 = k - radius * w;\r\n            // walk through y-neighbors\r\n            for (j = start; j < end; j++) {\r\n                val += data[k1 + j * w] * wg[j];\r\n            }\r\n            if (val > 0.5) {\r\n                result[k] = 1;\r\n                // check minmax\r\n                if (x < minX) minX = x;\r\n                if (x > maxX) maxX = x;\r\n                if (y < minY) minY = y;\r\n                if (y > maxY) maxY = y;\r\n            } else {\r\n                result[k] = 0;\r\n            }\r\n        }\r\n\r\n        return {\r\n            data: result,\r\n            width: w,\r\n            height: h,\r\n            bounds: {\r\n                minX: minX,\r\n                minY: minY,\r\n                maxX: maxX,\r\n                maxY: maxY\r\n            }\r\n        };\r\n    };\r\n\r\n    /** Create a border mask (only boundary points)\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n      */\r\n    lib.createBorderMask = function(mask) {\r\n\r\n        var x, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            rw = maxX - minX + 1, // bounds size\r\n            rh = maxY - minY + 1,\r\n            result = new Uint8Array(rw * rh), // reduced mask (bounds size)\r\n            x0 = Math.max(minX, 1),\r\n            x1 = Math.min(maxX, w - 2),\r\n            y0 = Math.max(minY, 1),\r\n            y1 = Math.min(maxY, h - 2);\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = y0; y < y1 + 1; y++)\r\n            for (x = x0; x < x1 + 1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                    data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                    data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                    //if (data[k + 1] + data[k - 1] + \r\n                    //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                    //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                    result[(y - minY) * rw + (x - minX)] = 1;\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        if (minX == 0)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w] === 1)\r\n                    result[(y - minY) * rw] = 1;\r\n\r\n        if (maxX == w - 1)\r\n            for (y = minY; y < maxY + 1; y++)\r\n                if (data[y * w + maxX] === 1)\r\n                    result[(y - minY) * rw + (maxX - minX)] = 1;\r\n\r\n        if (minY == 0)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[x] === 1)\r\n                    result[x - minX] = 1;\r\n\r\n        if (maxY == h - 1)\r\n            for (x = minX; x < maxX + 1; x++)\r\n                if (data[maxY * w + x] === 1)\r\n                    result[(maxY - minY) * rw + (x - minX)] = 1;\r\n\r\n        return {\r\n            data: result,\r\n            width: rw,\r\n            height: rh,\r\n            offset: { x: minX, y: minY }\r\n        };\r\n    };\r\n    \r\n    /** Create a border index array of boundary points of the mask\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height\r\n      * @return {Array} border index array boundary points of the mask\r\n      */\r\n    lib.getBorderIndices = function(mask) {\r\n\r\n        var x, y, k, k1, k2,\r\n            w = mask.width,\r\n            h = mask.height,\r\n            data = mask.data,\r\n            border = [], // only border points\r\n            x1 = w - 1,\r\n            y1 = h - 1;\r\n\r\n        // walk through inner values except points on the boundary of the image\r\n        for (y = 1; y < y1; y++)\r\n            for (x = 1; x < x1; x++) {\r\n                k = y * w + x;\r\n                if (data[k] === 0) continue; // \"white\" point isn't the border\r\n                k1 = k + w; // y + 1\r\n                k2 = k - w; // y - 1\r\n                // check if any neighbor with a \"white\" color\r\n                if (data[k + 1] === 0 || data[k - 1] === 0 ||\r\n                    data[k1] === 0 || data[k1 + 1] === 0 || data[k1 - 1] === 0 ||\r\n                    data[k2] === 0 || data[k2 + 1] === 0 || data[k2 - 1] === 0) {\r\n                    //if (data[k + 1] + data[k - 1] + \r\n                    //    data[k1] + data[k1 + 1] + data[k1 - 1] +\r\n                    //    data[k2] + data[k2 + 1] + data[k2 - 1] == 8) continue;\r\n                    border.push(k);\r\n                }\r\n            }\r\n\r\n        // walk through points on the boundary of the image if necessary\r\n        // if the \"black\" point is adjacent to the boundary of the image, it is a border point\r\n        for (y = 0; y < h; y++)\r\n            if (data[y * w] === 1)\r\n                border.push(y * w);\r\n\r\n        for (x = 0; x < w; x++)\r\n            if (data[x] === 1)\r\n                border.push(x);\r\n\r\n        k = w - 1;\r\n        for (y = 0; y < h; y++)\r\n            if (data[y * w + k] === 1)\r\n                border.push(y * w + k);\r\n\r\n        k = (h - 1) * w;\r\n        for (x = 0; x < w; x++)\r\n            if (data[k + x] === 1)\r\n                border.push(k + x);\r\n\r\n        return border;\r\n    };\r\n    \r\n    /** Create a compressed mask with a \"white\" border (1px border with zero values) for the contour tracing\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Object} border mask: {Uint8Array} data, {int} width, {int} height, {Object} offset\r\n      */\r\n    function prepareMask(mask) {\r\n        var x, y,\r\n            w = mask.width,\r\n            data = mask.data,\r\n            minX = mask.bounds.minX,\r\n            maxX = mask.bounds.maxX,\r\n            minY = mask.bounds.minY,\r\n            maxY = mask.bounds.maxY,\r\n            rw = maxX - minX + 3, // bounds size +1 px on each side (a \"white\" border)\r\n            rh = maxY - minY + 3,\r\n            result = new Uint8Array(rw * rh); // reduced mask (bounds size)\r\n\r\n        // walk through inner values and copy only \"black\" points to the result mask\r\n        for (y = minY; y < maxY + 1; y++)\r\n            for (x = minX; x < maxX + 1; x++) {\r\n                if (data[y * w + x] === 1)\r\n                    result[(y - minY + 1) * rw + (x - minX + 1)] = 1;\r\n            }\r\n\r\n        return {\r\n            data: result,\r\n            width: rw,\r\n            height: rh,\r\n            offset: { x: minX - 1, y: minY - 1 }\r\n        };\r\n    };\r\n        \r\n    /** Create a contour array for the binary mask\r\n      * Algorithm: http://www.sciencedirect.com/science/article/pii/S1077314203001401\r\n      * @param {Object} mask: {Uint8Array} data, {int} width, {int} height, {Object} bounds\r\n      * @return {Array} contours: {Array} points, {bool} inner, {int} label\r\n      */\r\n    lib.traceContours = function(mask) {\r\n        var m = prepareMask(mask),\r\n            contours = [],\r\n            label = 0,\r\n            w = m.width,\r\n            w2 = w * 2,\r\n            h = m.height,\r\n            src = m.data,\r\n            dx = m.offset.x,\r\n            dy = m.offset.y,\r\n            dest = new Uint8Array(src), // label matrix\r\n            i, j, x, y, k, k1, c, inner, dir, first, second, current, previous, next, d;\r\n\r\n        // all [dx,dy] pairs (array index is the direction)\r\n        // 5 6 7\r\n        // 4 X 0\r\n        // 3 2 1\r\n        var directions = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]];\r\n\r\n        for (y = 1; y < h - 1; y++)\r\n            for (x = 1; x < w - 1; x++) {\r\n                k = y * w + x;\r\n                if (src[k] === 1) {\r\n                    for (i = -w; i < w2; i += w2) { // k - w: outer tracing (y - 1), k + w: inner tracing (y + 1)\r\n                        if (src[k + i] === 0 && dest[k + i] === 0) { // need contour tracing\r\n                            inner = i === w; // is inner contour tracing ?\r\n                            label++; // label for the next contour\r\n\r\n                            c = [];\r\n                            dir = inner ? 2 : 6; // start direction\r\n                            current = previous = first = { x: x, y: y };\r\n                            second = null;\r\n                            while (true) {\r\n                                dest[current.y * w + current.x] = label; // mark label for the current point \r\n                                // bypass all the neighbors around the current point in a clockwise\r\n                                for (j = 0; j < 8; j++) {\r\n                                    dir = (dir + 1) % 8;\r\n\r\n                                    // get the next point by new direction\r\n                                    d = directions[dir]; // index as direction\r\n                                    next = { x: current.x + d[0], y: current.y + d[1] };\r\n\r\n                                    k1 = next.y * w + next.x;\r\n                                    if (src[k1] === 1) // black boundary pixel\r\n                                    {\r\n                                        dest[k1] = label; // mark a label\r\n                                        break;\r\n                                    }\r\n                                    dest[k1] = -1; // mark a white boundary pixel\r\n                                    next = null;\r\n                                }\r\n                                if (next === null) break; // no neighbours (one-point contour)\r\n                                current = next;\r\n                                if (second) {\r\n                                    if (previous.x === first.x && previous.y === first.y && current.x === second.x && current.y === second.y) {\r\n                                        break; // creating the contour completed when returned to original position\r\n                                    }\r\n                                } else {\r\n                                    second = next;\r\n                                }\r\n                                c.push({ x: previous.x + dx, y: previous.y + dy });\r\n                                previous = current;\r\n                                dir = (dir + 4) % 8; // next dir (symmetrically to the current direction)\r\n                            }\r\n\r\n                            if (next != null) {\r\n                                c.push({ x: first.x + dx, y: first.y + dy }); // close the contour\r\n                                contours.push({ inner: inner, label: label, points: c }); // add contour to the list\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        return contours;\r\n    };\r\n    \r\n    /** Simplify contours\r\n      * Algorithms: http://psimpl.sourceforge.net/douglas-peucker.html \r\n      * http://neerc.ifmo.ru/wiki/index.php?title=%D0%A3%D0%BF%D1%80%D0%BE%D1%89%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B8%D0%B3%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%86%D0%B5%D0%BF%D0%B8\r\n      * @param {Array} contours: {Array} points, {bool} inner, {int} label\r\n      * @param {float} simplify tolerant\r\n      * @param {int} simplify count: min number of points when the contour is simplified\r\n      * @return {Array} contours: {Array} points, {bool} inner, {int} label, {int} initialCount\r\n      */\r\n    lib.simplifyContours = function(contours, simplifyTolerant, simplifyCount) {\r\n        var lenContours = contours.length,\r\n            result = [],\r\n            i, j, k, c, points, len, resPoints, lst, stack, ids,\r\n            maxd, maxi, dist, r1, r2, r12, dx, dy, pi, pf, pl;\r\n\r\n        // walk through all contours \r\n        for (j = 0; j < lenContours; j++) {\r\n            c = contours[j];\r\n            points = c.points;\r\n            len = c.points.length;\r\n\r\n            if (len < simplifyCount) { // contour isn't simplified\r\n                resPoints = [];\r\n                for (k = 0; k < len; k++) {\r\n                    resPoints.push({ x: points[k].x, y: points[k].y });\r\n                }\r\n                result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: len });\r\n                continue;\r\n            }\r\n\r\n            lst = [0, len - 1]; // always add first and last points\r\n            stack = [{ first: 0, last: len - 1 }]; // first processed edge\r\n\r\n            do {\r\n                ids = stack.shift();\r\n                if (ids.last <= ids.first + 1) // no intermediate points\r\n                {\r\n                    continue;\r\n                }\r\n\r\n                maxd = -1.0; // max distance from point to current edge\r\n                maxi = ids.first; // index of maximally distant point\r\n\r\n                for (i = ids.first + 1; i < ids.last; i++) // bypass intermediate points in edge\r\n                {\r\n                    // calc the distance from current point to edge\r\n                    pi = points[i];\r\n                    pf = points[ids.first];\r\n                    pl = points[ids.last];\r\n                    dx = pi.x - pf.x;\r\n                    dy = pi.y - pf.y;\r\n                    r1 = Math.sqrt(dx * dx + dy * dy);\r\n                    dx = pi.x - pl.x;\r\n                    dy = pi.y - pl.y;\r\n                    r2 = Math.sqrt(dx * dx + dy * dy);\r\n                    dx = pf.x - pl.x;\r\n                    dy = pf.y - pl.y;\r\n                    r12 = Math.sqrt(dx * dx + dy * dy);\r\n                    if (r1 >= Math.sqrt(r2 * r2 + r12 * r12)) dist = r2;\r\n                    else if (r2 >= Math.sqrt(r1 * r1 + r12 * r12)) dist = r1;\r\n                    else dist = Math.abs((dy * pi.x - dx * pi.y + pf.x * pl.y - pl.x * pf.y) / r12);\r\n\r\n                    if (dist > maxd) {\r\n                        maxi = i; // save the index of maximally distant point\r\n                        maxd = dist;\r\n                    }\r\n                }\r\n\r\n                if (maxd > simplifyTolerant) // if the max \"deviation\" is larger than allowed then...\r\n                {\r\n                    lst.push(maxi); // add index to the simplified list\r\n                    stack.push({ first: ids.first, last: maxi }); // add the left part for processing\r\n                    stack.push({ first: maxi, last: ids.last }); // add the right part for processing\r\n                }\r\n\r\n            } while (stack.length > 0);\r\n\r\n            resPoints = [];\r\n            len = lst.length;\r\n            lst.sort(function(a, b) { return a - b; }); // restore index order\r\n            for (k = 0; k < len; k++) {\r\n                resPoints.push({ x: points[lst[k]].x, y: points[lst[k]].y }); // add result points to the correct order\r\n            }\r\n            result.push({ inner: c.inner, label: c.label, points: resPoints, initialCount: c.points.length });\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    return lib;\r\n})();\r\n\r\nmodule.exports = MagicWand;\r\n"],"names":[],"mappings":";;;;;;;;;;;AACA,SAAS,GAAG,CAAC,YAAY;IACrB,IAAI,GAAG,GAAG,EAAE,CAAC;;;;;;;;;;;;IAYb,GAAG,CAAC,SAAS,GAAG,SAAS,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE,cAAc,EAAE;QAC1E,OAAO,cAAc;cACf,oBAAoB,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,CAAC;cACzD,uBAAuB,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,CAAC,CAAC;KACtE,CAAC;;IAEF,SAAS,uBAAuB,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE;;QAElE,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM;YAC5C,IAAI,GAAG,KAAK,CAAC,IAAI;YACjB,CAAC,GAAG,KAAK,CAAC,KAAK;YACf,CAAC,GAAG,KAAK,CAAC,MAAM;YAChB,KAAK,GAAG,KAAK,CAAC,KAAK;YACnB,IAAI,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,GAAG,CAAC;YAChD,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE;YACf,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC;YAC9B,OAAO,GAAG,IAAI,UAAU,CAAC,IAAI,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;QAElD,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC;;QAElC,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACd,IAAI,WAAW,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;QAEnE,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;QAC7D,GAAG;YACC,EAAE,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;;YAEnB,MAAM,GAAG,KAAK,CAAC;YACf,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;gBACrC,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;gBACd,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,IAAI,KAAK,CAAC;;gBAErB,IAAI,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,SAAS;;gBAEpC,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC7B,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS;gBACxD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS;gBACxD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS;;gBAExD,MAAM,GAAG,IAAI,CAAC;;gBAEd,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;gBACnB,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;;gBAEpB,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEX,OAAO,EAAE,GAAG,CAAC,CAAC,EAAE;oBACZ,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;oBACd,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC;oBAChB,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,MAAM;;oBAE9B,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC7B,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;;oBAErD,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;oBAEjB,EAAE,EAAE,CAAC;iBACR;gBACD,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEX,OAAO,EAAE,GAAG,CAAC,EAAE;oBACX,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;oBACd,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC;oBAChB,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,MAAM;;oBAE9B,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC7B,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;;oBAErD,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;;oBAEjB,EAAE,EAAE,CAAC;iBACR;;;gBAGD,IAAI,EAAE,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC;gBAC7B,IAAI,EAAE,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC;;gBAE7B,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;gBACrB,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,EAAE;oBACvB,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;oBAClF,IAAI,EAAE,CAAC,KAAK,GAAG,EAAE,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;iBACvF;gBACD,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;gBACrB,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,EAAE;oBACvB,IAAI,EAAE,GAAG,EAAE,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;iBAC1E;aACJ;;YAED,IAAI,MAAM,EAAE;gBACR,IAAI,EAAE,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC;gBAC7B,IAAI,EAAE,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC;aAChC;SACJ,QAAQ,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;;QAE3B,OAAO;YACH,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,KAAK,CAAC,KAAK;YAClB,MAAM,EAAE,KAAK,CAAC,MAAM;YACpB,MAAM,EAAE;gBACJ,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;aACb;SACJ,CAAC;KACL,AACL;IACI,SAAS,oBAAoB,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,EAAE,cAAc,EAAE,IAAI,EAAE;;QAE/D,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,MAAM;YAC5C,IAAI,GAAG,KAAK,CAAC,IAAI;YACjB,CAAC,GAAG,KAAK,CAAC,KAAK;YACf,CAAC,GAAG,KAAK,CAAC,MAAM;YAChB,KAAK,GAAG,KAAK,CAAC,KAAK;YACnB,IAAI,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,GAAG,CAAC,EAAE,IAAI,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,CAAC,GAAG,CAAC;YAChD,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE;YACf,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC;YAC9B,OAAO,GAAG,IAAI,UAAU,CAAC,IAAI,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;QAElD,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,OAAO,IAAI,CAAC;;QAElC,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;QACd,IAAI,WAAW,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;QAEnE,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,CAAC,EAAE,KAAK,EAAE,EAAE,GAAG,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;QAC7D,GAAG;YACC,EAAE,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;;YAEnB,MAAM,GAAG,KAAK,CAAC;YACf,KAAK,CAAC,GAAG,EAAE,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;gBACrC,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;gBACd,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,IAAI,KAAK,CAAC;;gBAErB,IAAI,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE,SAAS;;gBAEpC,MAAM,GAAG,IAAI,CAAC;;gBAEd,MAAM,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;gBACnB,OAAO,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;;;gBAGpB,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC7B,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS;gBACxD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS;gBACxD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;gBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,SAAS;;gBAExD,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEX,OAAO,EAAE,GAAG,CAAC,CAAC,EAAE;oBACZ,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;oBACd,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC;oBAChB,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,MAAM;;oBAE9B,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBACjB,EAAE,EAAE,CAAC;;;oBAGL,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC7B,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;iBACxD;gBACD,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEX,OAAO,EAAE,GAAG,CAAC,EAAE;oBACX,GAAG,GAAG,EAAE,GAAG,EAAE,CAAC;oBACd,CAAC,GAAG,GAAG,GAAG,KAAK,CAAC;oBAChB,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,MAAM;;oBAE9B,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBAChB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBACjB,EAAE,EAAE,CAAC;;;oBAGL,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC7B,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;oBACrD,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjC,IAAI,CAAC,GAAG,cAAc,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,MAAM;iBACxD;;;gBAGD,IAAI,EAAE,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC;gBAC7B,IAAI,EAAE,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC;;gBAE7B,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;gBACrB,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,EAAE;oBACvB,IAAI,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;oBAClF,IAAI,EAAE,CAAC,KAAK,GAAG,EAAE,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;iBACvF;gBACD,IAAI,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC;gBACrB,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,CAAC,EAAE;oBACvB,IAAI,EAAE,GAAG,EAAE,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;iBAC1E;aACJ;;YAED,IAAI,MAAM,EAAE;gBACR,IAAI,EAAE,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC;gBAC7B,IAAI,EAAE,CAAC,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC,CAAC;aAChC;SACJ,QAAQ,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;;QAE3B,OAAO;YACH,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,KAAK,CAAC,KAAK;YAClB,MAAM,EAAE,KAAK,CAAC,MAAM;YACpB,MAAM,EAAE;gBACJ,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;aACb;SACJ,CAAC;KACL,AACL;;;;;;;;;IASI,GAAG,CAAC,SAAS,GAAG,SAAS,IAAI,EAAE,MAAM,EAAE;;QAEnC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;YAC/B,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC;YAClB,EAAE,GAAG,MAAM,GAAG,MAAM;YACpB,EAAE,GAAG,IAAI,YAAY,CAAC,CAAC,CAAC;YACxB,KAAK,GAAG,CAAC;YACT,CAAC,GAAG,IAAI,CAAC,KAAK;YACd,CAAC,GAAG,IAAI,CAAC,MAAM;YACf,IAAI,GAAG,IAAI,CAAC,IAAI;YAChB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;;;QAG5B,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YACzB,IAAI,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK,MAAM,GAAG,CAAC,CAAC,CAAC;YACtC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,GAAG,GAAG,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;YAC1D,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;YACrC,KAAK,IAAI,CAAC,GAAG,EAAE,CAAC;SACnB;;QAED,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YACpB,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;SAClB;;QAED,IAAI,MAAM,GAAG,IAAI,UAAU,CAAC,CAAC,GAAG,CAAC,CAAC;YAC9B,IAAI,GAAG,MAAM,GAAG,CAAC;YACjB,IAAI,GAAG,MAAM,GAAG,CAAC,CAAC;;;QAGtB,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;YAC5B,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC9B,GAAG,GAAG,CAAC,CAAC;gBACR,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACd,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;gBACxC,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;gBAClC,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC;;gBAEhB,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;oBAC1B,GAAG,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;iBAC/B;gBACD,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;gBACxC,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;gBAClC,EAAE,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC;;gBAEpB,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;oBAC1B,GAAG,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;iBACnC;gBACD,MAAM,CAAC,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;aACjC;;QAEL,OAAO;YACH,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,CAAC;YACR,MAAM,EAAE,CAAC;YACT,MAAM,EAAE;gBACJ,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;aACb;SACJ,CAAC;KACL,CAAC;;;;;;;;IAQF,SAAS,mBAAmB,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE;;QAEhD,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE;YACrB,CAAC,GAAG,IAAI,CAAC,KAAK;YACd,CAAC,GAAG,IAAI,CAAC,MAAM;YACf,IAAI,GAAG,IAAI,CAAC,IAAI;YAChB,WAAW,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC;YAClC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,GAAG,GAAG,CAAC,GAAG,CAAC;YACX,IAAI,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC;YAC1B,MAAM,GAAG,EAAE;YACX,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACtB,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC;YAC1B,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACtB,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;;QAE/B,IAAI,OAAO,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;;YAE/B,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBACtB,IAAI,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;aAC5C;SACJ;;;QAGD,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE;YACxB,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC1B,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACd,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,SAAS;gBAC5B,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;gBACX,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEX,IAAI,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACpD,WAAW,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC;oBAC/E,WAAW,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,WAAW,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;;;;oBAIjF,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBAClB;aACJ;;;;QAIL,IAAI,IAAI,IAAI,CAAC;YACT,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACjB,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;QAE/B,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC;YACb,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;oBACxB,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;;QAEtC,IAAI,IAAI,IAAI,CAAC;YACT,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;oBACb,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;QAE3B,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC;YACb,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACxB,MAAM,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;QAEtC,IAAI,MAAM,GAAG,EAAE;YACX,KAAK,EAAE,GAAG;YACV,IAAI,GAAG,MAAM,GAAG,CAAC;YACjB,IAAI,GAAG,MAAM,GAAG,CAAC;YACjB,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;;QAEvB,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;;QAEpB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACtB,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACd,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YACZ,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACf,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACV,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAChB,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;YACxC,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;YAClC,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC;;YAEhB,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAC1B,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;gBACZ,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE;oBAChB,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;oBACb,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;iBACnB;aACJ;YACD,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;YACxC,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;YAClC,EAAE,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC;;YAEpB,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAC1B,EAAE,GAAG,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;gBAChB,IAAI,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE;oBAChB,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC;oBACb,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;iBACnB;aACJ;SACJ;;QAED,OAAO,MAAM,CAAC;KACjB,AACL;;;;;;;;;;IAUI,GAAG,CAAC,mBAAmB,GAAG,SAAS,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE;;QAEtD,IAAI,MAAM,GAAG,mBAAmB,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC;YACnD,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;YAC3C,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC;YAClB,EAAE,GAAG,CAAC,GAAG,MAAM,GAAG,MAAM;YACxB,EAAE,GAAG,IAAI,YAAY,CAAC,CAAC,CAAC;YACxB,KAAK,GAAG,CAAC;YACT,CAAC,GAAG,IAAI,CAAC,KAAK;YACd,CAAC,GAAG,IAAI,CAAC,MAAM;YACf,IAAI,GAAG,IAAI,CAAC,IAAI;YAChB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;;;QAGxB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,EAAE;YACzB,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,KAAK,MAAM,GAAG,CAAC,CAAC,CAAC;YAClC,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,CAAC;YACnC,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;YACrC,KAAK,IAAI,CAAC,GAAG,EAAE,CAAC;SACnB;;QAED,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;YACpB,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC;SAClB;;QAED,IAAI,MAAM,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC;YAC7B,IAAI,GAAG,MAAM,GAAG,CAAC;YACjB,IAAI,GAAG,MAAM,GAAG,CAAC,CAAC;;;QAGtB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACtB,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACd,GAAG,GAAG,CAAC,CAAC;YACR,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;YACV,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAChB,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;YACxC,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;YAClC,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC;;YAEhB,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAC1B,GAAG,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;aAC/B;YACD,IAAI,GAAG,GAAG,GAAG,EAAE;gBACX,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;;gBAEd,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,SAAS;aACZ;YACD,KAAK,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC;YACxC,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC;YAClC,EAAE,GAAG,CAAC,GAAG,MAAM,GAAG,CAAC,CAAC;;YAEpB,KAAK,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBAC1B,GAAG,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;aACnC;YACD,IAAI,GAAG,GAAG,GAAG,EAAE;gBACX,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;;gBAEd,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;gBACvB,IAAI,CAAC,GAAG,IAAI,EAAE,IAAI,GAAG,CAAC,CAAC;aAC1B,MAAM;gBACH,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;aACjB;SACJ;;QAED,OAAO;YACH,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,CAAC;YACR,MAAM,EAAE,CAAC;YACT,MAAM,EAAE;gBACJ,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;aACb;SACJ,CAAC;KACL,CAAC;;;;;;IAMF,GAAG,CAAC,gBAAgB,GAAG,SAAS,IAAI,EAAE;;QAElC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE;YACf,CAAC,GAAG,IAAI,CAAC,KAAK;YACd,CAAC,GAAG,IAAI,CAAC,MAAM;YACf,IAAI,GAAG,IAAI,CAAC,IAAI;YAChB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,CAAC;YACpB,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,CAAC;YACpB,MAAM,GAAG,IAAI,UAAU,CAAC,EAAE,GAAG,EAAE,CAAC;YAChC,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACtB,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC;YAC1B,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACtB,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;;;QAG/B,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE;YACxB,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC1B,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACd,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,SAAS;gBAC5B,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;gBACX,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEX,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACtC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC;oBAC1D,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;;;;oBAI5D,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;iBAC5C;aACJ;;;;QAIL,IAAI,IAAI,IAAI,CAAC;YACT,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACjB,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,EAAE,CAAC,GAAG,CAAC,CAAC;;QAExC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC;YACb,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC;oBACxB,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,IAAI,EAAE,IAAI,IAAI,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;;QAExD,IAAI,IAAI,IAAI,CAAC;YACT,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;oBACb,MAAM,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC;;QAEjC,IAAI,IAAI,IAAI,CAAC,GAAG,CAAC;YACb,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;gBAC5B,IAAI,IAAI,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACxB,MAAM,CAAC,CAAC,IAAI,GAAG,IAAI,IAAI,EAAE,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;;QAExD,OAAO;YACH,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,EAAE;YACT,MAAM,EAAE,EAAE;YACV,MAAM,EAAE,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE;SAC/B,CAAC;KACL,CAAC;;;;;;IAMF,GAAG,CAAC,gBAAgB,GAAG,SAAS,IAAI,EAAE;;QAElC,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE;YACf,CAAC,GAAG,IAAI,CAAC,KAAK;YACd,CAAC,GAAG,IAAI,CAAC,MAAM;YACf,IAAI,GAAG,IAAI,CAAC,IAAI;YAChB,MAAM,GAAG,EAAE;YACX,EAAE,GAAG,CAAC,GAAG,CAAC;YACV,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;;QAGf,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE;YACnB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE;gBACrB,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACd,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE,SAAS;gBAC5B,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;gBACX,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;;gBAEX,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACtC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC;oBAC1D,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;;;;oBAI5D,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;iBAClB;aACJ;;;;QAIL,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YAClB,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;gBACjB,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;QAE3B,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YAClB,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC;gBACb,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;;QAEvB,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QACV,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YAClB,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;gBACrB,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;;QAE/B,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAChB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YAClB,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;gBACjB,MAAM,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;QAE3B,OAAO,MAAM,CAAC;KACjB,CAAC;;;;;;IAMF,SAAS,WAAW,CAAC,IAAI,EAAE;QACvB,IAAI,CAAC,EAAE,CAAC;YACJ,CAAC,GAAG,IAAI,CAAC,KAAK;YACd,IAAI,GAAG,IAAI,CAAC,IAAI;YAChB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI;YACvB,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,CAAC;YACpB,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,CAAC;YACpB,MAAM,GAAG,IAAI,UAAU,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC;;;QAGrC,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE;YAC5B,KAAK,CAAC,GAAG,IAAI,EAAE,CAAC,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBAC9B,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC;oBACrB,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;aACxD;;QAEL,OAAO;YACH,IAAI,EAAE,MAAM;YACZ,KAAK,EAAE,EAAE;YACT,MAAM,EAAE,EAAE;YACV,MAAM,EAAE,EAAE,CAAC,EAAE,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,GAAG,CAAC,EAAE;SACvC,CAAC;KACL,AACL;;;;;;IAMI,GAAG,CAAC,aAAa,GAAG,SAAS,IAAI,EAAE;QAC/B,IAAI,CAAC,GAAG,WAAW,CAAC,IAAI,CAAC;YACrB,QAAQ,GAAG,EAAE;YACb,KAAK,GAAG,CAAC;YACT,CAAC,GAAG,CAAC,CAAC,KAAK;YACX,EAAE,GAAG,CAAC,GAAG,CAAC;YACV,CAAC,GAAG,CAAC,CAAC,MAAM;YACZ,GAAG,GAAG,CAAC,CAAC,IAAI;YACZ,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;YACf,EAAE,GAAG,CAAC,CAAC,MAAM,CAAC,CAAC;YACf,IAAI,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC;YAC1B,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;;;;;;QAMhF,IAAI,UAAU,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;;QAExF,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;YACtB,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;gBACxB,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACd,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;oBACd,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,IAAI,EAAE,EAAE;wBAC1B,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,EAAE;4BACvC,KAAK,GAAG,CAAC,KAAK,CAAC,CAAC;4BAChB,KAAK,EAAE,CAAC;;4BAER,CAAC,GAAG,EAAE,CAAC;4BACP,GAAG,GAAG,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC;4BACpB,OAAO,GAAG,QAAQ,GAAG,KAAK,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;4BAC5C,MAAM,GAAG,IAAI,CAAC;4BACd,OAAO,IAAI,EAAE;gCACT,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;;gCAExC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;oCACpB,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;;;oCAGpB,CAAC,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC;oCACpB,IAAI,GAAG,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;;oCAEpD,EAAE,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;oCACzB,IAAI,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC;oCACjB;wCACI,IAAI,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC;wCACjB,MAAM;qCACT;oCACD,IAAI,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;oCACd,IAAI,GAAG,IAAI,CAAC;iCACf;gCACD,IAAI,IAAI,KAAK,IAAI,EAAE,MAAM;gCACzB,OAAO,GAAG,IAAI,CAAC;gCACf,IAAI,MAAM,EAAE;oCACR,IAAI,QAAQ,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,IAAI,QAAQ,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,KAAK,MAAM,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,KAAK,MAAM,CAAC,CAAC,EAAE;wCACtG,MAAM;qCACT;iCACJ,MAAM;oCACH,MAAM,GAAG,IAAI,CAAC;iCACjB;gCACD,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;gCACnD,QAAQ,GAAG,OAAO,CAAC;gCACnB,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;6BACvB;;4BAED,IAAI,IAAI,IAAI,IAAI,EAAE;gCACd,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;gCAC7C,QAAQ,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;6BAC5D;yBACJ;qBACJ;iBACJ;aACJ;;QAEL,OAAO,QAAQ,CAAC;KACnB,CAAC;;;;;;;;;;IAUF,GAAG,CAAC,gBAAgB,GAAG,SAAS,QAAQ,EAAE,gBAAgB,EAAE,aAAa,EAAE;QACvE,IAAI,WAAW,GAAG,QAAQ,CAAC,MAAM;YAC7B,MAAM,GAAG,EAAE;YACX,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,MAAM,EAAE,GAAG,EAAE,SAAS,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;YACnD,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;;;QAGtD,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,EAAE,CAAC,EAAE,EAAE;YAC9B,CAAC,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;YAChB,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC;YAClB,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC;;YAEtB,IAAI,GAAG,GAAG,aAAa,EAAE;gBACrB,SAAS,GAAG,EAAE,CAAC;gBACf,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;oBACtB,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;iBACtD;gBACD,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,YAAY,EAAE,GAAG,EAAE,CAAC,CAAC;gBACtF,SAAS;aACZ;;YAED,GAAG,GAAG,CAAC,CAAC,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC;YACnB,KAAK,GAAG,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,IAAI,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC,CAAC;;YAEtC,GAAG;gBACC,GAAG,GAAG,KAAK,CAAC,KAAK,EAAE,CAAC;gBACpB,IAAI,GAAG,CAAC,IAAI,IAAI,GAAG,CAAC,KAAK,GAAG,CAAC;gBAC7B;oBACI,SAAS;iBACZ;;gBAED,IAAI,GAAG,CAAC,GAAG,CAAC;gBACZ,IAAI,GAAG,GAAG,CAAC,KAAK,CAAC;;gBAEjB,KAAK,CAAC,GAAG,GAAG,CAAC,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE;gBACzC;;oBAEI,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;oBACf,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;oBACvB,EAAE,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;oBACtB,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;oBACjB,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;oBACjB,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;oBAClC,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;oBACjB,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;oBACjB,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;oBAClC,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;oBACjB,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;oBACjB,GAAG,GAAG,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;oBACnC,IAAI,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,IAAI,GAAG,EAAE,CAAC;yBAC/C,IAAI,EAAE,IAAI,IAAI,CAAC,IAAI,CAAC,EAAE,GAAG,EAAE,GAAG,GAAG,GAAG,GAAG,CAAC,EAAE,IAAI,GAAG,EAAE,CAAC;yBACpD,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC;;oBAEhF,IAAI,IAAI,GAAG,IAAI,EAAE;wBACb,IAAI,GAAG,CAAC,CAAC;wBACT,IAAI,GAAG,IAAI,CAAC;qBACf;iBACJ;;gBAED,IAAI,IAAI,GAAG,gBAAgB;gBAC3B;oBACI,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBACf,KAAK,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,GAAG,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;oBAC7C,KAAK,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;iBAC/C;;aAEJ,QAAQ,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;;YAE3B,SAAS,GAAG,EAAE,CAAC;YACf,GAAG,GAAG,GAAG,CAAC,MAAM,CAAC;YACjB,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,EAAE,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;YAC3C,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;gBACtB,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;aAChE;YACD,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,CAAC,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,YAAY,EAAE,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,CAAC;SACrG;;QAED,OAAO,MAAM,CAAC;KACjB,CAAC;;IAEF,OAAO,GAAG,CAAC;CACd,GAAG,CAAC;;AAEL,MAAM,CAAC,OAAO,GAAG,SAAS,CAAC"}